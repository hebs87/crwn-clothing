{"ast":null,"code":"// Import takeEvery to listen to every action of specific type\n// Import call to enable creating the collectionsMap\n// Import put to enable us to dispatch any actions\nimport { takeEvery, call, put } from 'redux-saga/effects'; // Import relevant utilities from firebase utils\n\nimport { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils'; // Import action creators from shop actions\n\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from './shop.actions';\nimport ShopActionTypes from './shop.types'; // This generator function will be passed into the\n// fetchCollectionsStart generator function\n// This handled our code for the async request to\n// fetch the shop data\n\nexport function* fetchCollectionsAsync() {\n  // We want to call the firestore.collection and pass\n  // in the name of our collection. This gets the\n  // 'collections' collection from firebase and stores\n  // it in the collectionRef const\n  const collectionRef = firestore.collection('collections'); // Instead of using the promise get().then() method that\n  // we used in our thunk code, we instead create a snapshot\n  // const that will be equal to the yielded value of running\n  // collectionReg.get(). When this value comes back, it does\n  // so in a promise form that gets resolved with the value\n  // of our collection reference, and stores it in our snapshot\n\n  const snapshot = yield collectionRef.get(); // call is the effect inside the generator function that invokes\n  // the method. It takes a function or method as its first argument\n  // and the parameters as the remaining arguments\n  // In this instance it takes the convertCollectionsSnapshotToMap\n  // function and passes in the snapshot parameter to create a\n  // collectionsMap\n\n  const collectionsMap = yield call(convertCollectionsSnapshotToMap, snapshot); // put is the saga effect for dispatching actions\n  // The only difference to dispatch() is that we have to\n  // yield it. So we need to pass in our fetchCollectionsSuccess\n  // action and pass in the collectionsMap\n\n  yield put(fetchCollectionsSuccess(collectionsMap));\n}\n; // We build our fetchCollectionsStart generator function\n// which is declared using the function* syntax\n// The generator function uses the takeEvery method which\n// listens to every action of a specific type (first argument),\n// and also a second generator function (second argument) - this\n// is how we step through the yield code\n\nexport function* fetchCollectionsStart() {\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}\n;","map":{"version":3,"sources":["/workspace/crwn-clothing/src/redux/shop/shop.sagas.js"],"names":["takeEvery","call","put","firestore","convertCollectionsSnapshotToMap","fetchCollectionsSuccess","fetchCollectionsFailure","ShopActionTypes","fetchCollectionsAsync","collectionRef","collection","snapshot","get","collectionsMap","fetchCollectionsStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAT,EAAoBC,IAApB,EAA0BC,GAA1B,QAAqC,oBAArC,C,CAEA;;AACA,SACIC,SADJ,EAEIC,+BAFJ,QAGO,+BAHP,C,CAKA;;AACA,SACIC,uBADJ,EAEIC,uBAFJ,QAGO,gBAHP;AAKA,OAAOC,eAAP,MAA4B,cAA5B,C,CAEA;AACA;AACA;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACrC;AACA;AACA;AACA;AACA,QAAMC,aAAa,GAAGN,SAAS,CAACO,UAAV,CAAqB,aAArB,CAAtB,CALqC,CAMrC;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAZqC,CAarC;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMC,cAAc,GAAG,MAAMZ,IAAI,CAACG,+BAAD,EAAkCO,QAAlC,CAAjC,CAnBqC,CAoBrC;AACA;AACA;AACA;;AACA,QAAMT,GAAG,CAACG,uBAAuB,CAACQ,cAAD,CAAxB,CAAT;AACH;AAAA,C,CAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACrC,QAAMd,SAAS,CACXO,eAAe,CAACQ,uBADL,EAEXP,qBAFW,CAAf;AAIH;AAAA","sourcesContent":["// Import takeEvery to listen to every action of specific type\n// Import call to enable creating the collectionsMap\n// Import put to enable us to dispatch any actions\nimport { takeEvery, call, put } from 'redux-saga/effects';\n\n// Import relevant utilities from firebase utils\nimport {\n    firestore,\n    convertCollectionsSnapshotToMap\n} from '../../firebase/firebase.utils';\n\n// Import action creators from shop actions\nimport {\n    fetchCollectionsSuccess,\n    fetchCollectionsFailure\n} from './shop.actions';\n\nimport ShopActionTypes from './shop.types';\n\n// This generator function will be passed into the\n// fetchCollectionsStart generator function\n// This handled our code for the async request to\n// fetch the shop data\nexport function* fetchCollectionsAsync() {\n    // We want to call the firestore.collection and pass\n    // in the name of our collection. This gets the\n    // 'collections' collection from firebase and stores\n    // it in the collectionRef const\n    const collectionRef = firestore.collection('collections');\n    // Instead of using the promise get().then() method that\n    // we used in our thunk code, we instead create a snapshot\n    // const that will be equal to the yielded value of running\n    // collectionReg.get(). When this value comes back, it does\n    // so in a promise form that gets resolved with the value\n    // of our collection reference, and stores it in our snapshot\n    const snapshot = yield collectionRef.get();\n    // call is the effect inside the generator function that invokes\n    // the method. It takes a function or method as its first argument\n    // and the parameters as the remaining arguments\n    // In this instance it takes the convertCollectionsSnapshotToMap\n    // function and passes in the snapshot parameter to create a\n    // collectionsMap\n    const collectionsMap = yield call(convertCollectionsSnapshotToMap, snapshot);\n    // put is the saga effect for dispatching actions\n    // The only difference to dispatch() is that we have to\n    // yield it. So we need to pass in our fetchCollectionsSuccess\n    // action and pass in the collectionsMap\n    yield put(fetchCollectionsSuccess(collectionsMap))\n};\n\n// We build our fetchCollectionsStart generator function\n// which is declared using the function* syntax\n// The generator function uses the takeEvery method which\n// listens to every action of a specific type (first argument),\n// and also a second generator function (second argument) - this\n// is how we step through the yield code\nexport function* fetchCollectionsStart() {\n    yield takeEvery(\n        ShopActionTypes.FETCH_COLLECTIONS_START,\n        fetchCollectionsAsync\n    );\n};\n"]},"metadata":{},"sourceType":"module"}