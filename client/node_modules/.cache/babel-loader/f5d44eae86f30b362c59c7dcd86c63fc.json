{"ast":null,"code":"// Always need the base import\nimport firebase from 'firebase/app'; // Import firestore for the DB\n\nimport 'firebase/firestore'; // Import auth for the authentication\n\nimport 'firebase/auth'; // This is the object we copied from Firebase\n\nconst config = {\n  apiKey: \"AIzaSyA--jLyuullxBq7H8U2VujzwswILTes3wA\",\n  authDomain: \"crwn-db-b90c5.firebaseapp.com\",\n  databaseURL: \"https://crwn-db-b90c5.firebaseio.com\",\n  projectId: \"crwn-db-b90c5\",\n  storageBucket: \"crwn-db-b90c5.appspot.com\",\n  messagingSenderId: \"645870761803\",\n  appId: \"1:645870761803:web:daf925f13e5cd8b6e39ace\",\n  measurementId: \"G-VPEMW2RJM6\"\n};\nfirebase.initializeApp(config); // We create an asynchronous function to pull the userAuth\n// object that is generated when a user logs in, and we then\n// use it to store the relevant information in the DB\n// We also want to pass in additionalData that we might use later\n\nexport const createUserProfileDocument = async (userAuth, additionalData) => {\n  // We only want to create a document if there is a userAuth,\n  // so if the value isn't null. So if there is no userAuth,\n  // we want to return out of the function\n  if (!userAuth) return; // We store the userAuth's uid in a userRef const\n  // We then get the userRef from the DB to see if it has\n  // any data, and store the result of this async method\n  // in a snapShot const\n\n  const userRef = firestore.doc(`users/${userAuth.uid}`);\n  const snapShot = await userRef.get(); // If the snapShot doesn't exist, we want to get the values,\n  // set them and create a document in the collection\n\n  if (!snapShot.exists) {\n    const {\n      displayName,\n      email\n    } = userAuth;\n    const createdAt = new Date();\n\n    try {\n      await userRef.set({\n        displayName,\n        email,\n        createdAt,\n        ...additionalData\n      });\n    } catch (error) {\n      console.log('Error creating user', error.message);\n    }\n  }\n\n  return userRef;\n}; // We want to write a util that allows us to batch our\n// data and move it to the database in one go, to avoid\n// us having to manually add it to our database - this\n// will be an asynchronous util.\n// It takes the collectionKey and the objectsToAdd\n\nexport const addCollectionAndDocuments = async (collectionKey, objectsToAdd) => {\n  // First, we want to create the collection in firebase\n  // using the collectionKey of the collection in our app\n  const collectionRef = firestore.collection(collectionKey); // We can only write one document to firestore at once, so\n  // we want to use batch() to batch write the documents first,\n  // and then add them all to firestore. This will ensure that\n  // if one or more documents fail to upload, the whole process\n  // will fail\n\n  const batch = firestore.batch(); // We loop over our objectsToAdd array using the forEach()\n  // method - this difference between this and .map() is that\n  // a new array isn't created, which is what we want\n\n  objectsToAdd.forEach(obj => {\n    // We are telling firebase to give us a new document\n    // reference in this collection and randomly generate\n    // an ID for it\n    const newDocRef = collectionRef.doc(); // We then call batch.set() so that we batch the requests\n    // We pass it the newDocRef and the value we want to set\n    // it to - obj in this instance\n\n    batch.set(newDocRef, obj);\n  }); // We then want to commit our batch - this returns a promise\n  // When commit() succeeds, it will return us a null value,\n  // which is useful if we want to use .then to do something\n  // after it succeeds, or if we want to handle errors too\n\n  return await batch.commit();\n}; // We want to write a util that gets our snapshot shop data\n// from firebase and converts it to an object with the object\n// structure that we ultimately want to pass in to our shop\n// reducer - collections is the snapshot object that we will\n// pass in from our ShopData component\n\nexport const convertCollectionsSnapshotToMap = collections => {\n  // We want to use .docs to get the documentSnapshot,\n  // then we can map over it and pull the data that we\n  // want - the title and the items\n  const transformedCollection = collections.docs.map(doc => {\n    const {\n      title,\n      items\n    } = doc.data(); // We then want to return an object that represents the\n    // final data object that we want for our front-end app,\n    // including the routeName, id, title and items\n\n    return {\n      // encodeURI is a JavaScript method which takes a\n      // string and converts any special characters that\n      // a URL can't read, and converts them into a value\n      // that the URL can read. In this instance, the\n      // routeName is the same as the title, but in lower\n      // case, so we want to pass in the title and convert\n      // it to lower case\n      routeName: encodeURI(title.toLowerCase()),\n      // We get the ID from the doc itself, rather than\n      // the data\n      id: doc.id,\n      title,\n      items\n    };\n  }); // We want to reduce our transformedCollection to give us\n  // the final data structure that we need, which we can pass\n  // into our reducer.\n  // The second parameter of our reduce is going to be an\n  // empty object, which will be the accumulator's starting value\n  // The first param will be a function that gets our accumulator\n  // and also the collection at the current iteration.\n  // Inside the function, we want to set the accumulator key to\n  // the lower case title of the function, and then make the key\n  // equal to the collection itself - so the hats key will get\n  // the hats collection, the jackets key will get the jackets\n  // collection, and so on, until there are no more collections\n  // to iterate/reduce over. We return the accumulator on each\n  // iteration, so that become the new value of the accumulator\n  // for the next iteration.\n  // The iterations occur until there are no more collections\n  // left and we have the final object.\n\n  return transformedCollection.reduce((accumulator, collection) => {\n    accumulator[collection.title.toLowerCase()] = collection;\n    return accumulator;\n  }, {});\n}; // Export this so we can call the auth whenever we want it\n\nexport const auth = firebase.auth(); // Export firestore so we can call it when needed\n\nexport const firestore = firebase.firestore(); // Google authentication utility (in the Firebase documentation)\n\nexport const googleProvider = new firebase.auth.GoogleAuthProvider(); // We trigger the sign in pop up window when we want to sign in\n\ngoogleProvider.setCustomParameters({\n  prompt: 'select_account'\n});\nexport const signInWithGoogle = () => auth.signInWithPopup(googleProvider);\nexport default firebase;","map":{"version":3,"sources":["/workspace/crwn-clothing/src/firebase/firebase.utils.js"],"names":["firebase","config","apiKey","authDomain","databaseURL","projectId","storageBucket","messagingSenderId","appId","measurementId","initializeApp","createUserProfileDocument","userAuth","additionalData","userRef","firestore","doc","uid","snapShot","get","exists","displayName","email","createdAt","Date","set","error","console","log","message","addCollectionAndDocuments","collectionKey","objectsToAdd","collectionRef","collection","batch","forEach","obj","newDocRef","commit","convertCollectionsSnapshotToMap","collections","transformedCollection","docs","map","title","items","data","routeName","encodeURI","toLowerCase","id","reduce","accumulator","auth","googleProvider","GoogleAuthProvider","setCustomParameters","prompt","signInWithGoogle","signInWithPopup"],"mappings":"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","sourcesContent":["// Always need the base import\nimport firebase from 'firebase/app';\n// Import firestore for the DB\nimport 'firebase/firestore';\n// Import auth for the authentication\nimport 'firebase/auth';\n\n// This is the object we copied from Firebase\nconst config = {\n    apiKey: \"AIzaSyA--jLyuullxBq7H8U2VujzwswILTes3wA\",\n    authDomain: \"crwn-db-b90c5.firebaseapp.com\",\n    databaseURL: \"https://crwn-db-b90c5.firebaseio.com\",\n    projectId: \"crwn-db-b90c5\",\n    storageBucket: \"crwn-db-b90c5.appspot.com\",\n    messagingSenderId: \"645870761803\",\n    appId: \"1:645870761803:web:daf925f13e5cd8b6e39ace\",\n    measurementId: \"G-VPEMW2RJM6\"\n};\n\nfirebase.initializeApp(config);\n\n// We create an asynchronous function to pull the userAuth\n// object that is generated when a user logs in, and we then\n// use it to store the relevant information in the DB\n// We also want to pass in additionalData that we might use later\nexport const createUserProfileDocument = async (userAuth, additionalData) => {\n    // We only want to create a document if there is a userAuth,\n    // so if the value isn't null. So if there is no userAuth,\n    // we want to return out of the function\n    if (!userAuth) return;\n\n    // We store the userAuth's uid in a userRef const\n    // We then get the userRef from the DB to see if it has\n    // any data, and store the result of this async method\n    // in a snapShot const\n    const userRef = firestore.doc(`users/${userAuth.uid}`);\n    const snapShot = await userRef.get();\n\n    // If the snapShot doesn't exist, we want to get the values,\n    // set them and create a document in the collection\n    if (!snapShot.exists) {\n        const { displayName, email } = userAuth;\n        const createdAt = new Date();\n\n        try {\n            await userRef.set({\n                displayName,\n                email,\n                createdAt,\n                ...additionalData\n            })\n        } catch (error) {\n            console.log('Error creating user', error.message);\n        }\n    }\n\n    return userRef;\n};\n\n// We want to write a util that allows us to batch our\n// data and move it to the database in one go, to avoid\n// us having to manually add it to our database - this\n// will be an asynchronous util.\n// It takes the collectionKey and the objectsToAdd\nexport const addCollectionAndDocuments = async (\n    collectionKey,\n    objectsToAdd\n) => {\n    // First, we want to create the collection in firebase\n    // using the collectionKey of the collection in our app\n    const collectionRef = firestore.collection(collectionKey);\n    // We can only write one document to firestore at once, so\n    // we want to use batch() to batch write the documents first,\n    // and then add them all to firestore. This will ensure that\n    // if one or more documents fail to upload, the whole process\n    // will fail\n    const batch = firestore.batch();\n    // We loop over our objectsToAdd array using the forEach()\n    // method - this difference between this and .map() is that\n    // a new array isn't created, which is what we want\n    objectsToAdd.forEach(obj => {\n        // We are telling firebase to give us a new document\n        // reference in this collection and randomly generate\n        // an ID for it\n        const newDocRef = collectionRef.doc();\n        // We then call batch.set() so that we batch the requests\n        // We pass it the newDocRef and the value we want to set\n        // it to - obj in this instance\n        batch.set(newDocRef, obj);\n    });\n    // We then want to commit our batch - this returns a promise\n    // When commit() succeeds, it will return us a null value,\n    // which is useful if we want to use .then to do something\n    // after it succeeds, or if we want to handle errors too\n    return await batch.commit();\n};\n\n// We want to write a util that gets our snapshot shop data\n// from firebase and converts it to an object with the object\n// structure that we ultimately want to pass in to our shop\n// reducer - collections is the snapshot object that we will\n// pass in from our ShopData component\nexport const convertCollectionsSnapshotToMap = collections => {\n    // We want to use .docs to get the documentSnapshot,\n    // then we can map over it and pull the data that we\n    // want - the title and the items\n    const transformedCollection = collections.docs.map(doc => {\n        const { title, items } = doc.data();\n\n        // We then want to return an object that represents the\n        // final data object that we want for our front-end app,\n        // including the routeName, id, title and items\n        return {\n            // encodeURI is a JavaScript method which takes a\n            // string and converts any special characters that\n            // a URL can't read, and converts them into a value\n            // that the URL can read. In this instance, the\n            // routeName is the same as the title, but in lower\n            // case, so we want to pass in the title and convert\n            // it to lower case\n            routeName: encodeURI(title.toLowerCase()),\n            // We get the ID from the doc itself, rather than\n            // the data\n            id: doc.id,\n            title,\n            items\n        };\n    });\n\n    // We want to reduce our transformedCollection to give us\n    // the final data structure that we need, which we can pass\n    // into our reducer.\n    // The second parameter of our reduce is going to be an\n    // empty object, which will be the accumulator's starting value\n    // The first param will be a function that gets our accumulator\n    // and also the collection at the current iteration.\n    // Inside the function, we want to set the accumulator key to\n    // the lower case title of the function, and then make the key\n    // equal to the collection itself - so the hats key will get\n    // the hats collection, the jackets key will get the jackets\n    // collection, and so on, until there are no more collections\n    // to iterate/reduce over. We return the accumulator on each\n    // iteration, so that become the new value of the accumulator\n    // for the next iteration.\n    // The iterations occur until there are no more collections\n    // left and we have the final object.\n    return transformedCollection.reduce((accumulator, collection) => {\n        accumulator[collection.title.toLowerCase()] = collection;\n        return accumulator;\n    }, {});\n};\n\n// Export this so we can call the auth whenever we want it\nexport const auth = firebase.auth();\n// Export firestore so we can call it when needed\nexport const firestore = firebase.firestore();\n\n// Google authentication utility (in the Firebase documentation)\nexport const googleProvider = new firebase.auth.GoogleAuthProvider();\n// We trigger the sign in pop up window when we want to sign in\ngoogleProvider.setCustomParameters({ prompt: 'select_account' });\nexport const signInWithGoogle = () => auth.signInWithPopup(googleProvider);\n\nexport default firebase;"]},"metadata":{},"sourceType":"module"}