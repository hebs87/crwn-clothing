{"ast":null,"code":"// Import takeEvery to listen to every action of specific type\n// Import call to \n// Import put to \nimport { takeEvery, call, put } from 'redux-saga/effects'; // Import relevant utilities from firebase utils\n\nimport { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils'; // Import action creators from shop actions\n\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from './shop.actions';\nimport ShopActionTypes from './shop.types'; // This generator function will be passed into the\n// fetchCollectionsStart generator function\n// This handled our code for the async request to\n// fetch the shop data\n\nexport function* fetchCollectionsAsync() {\n  // We want to call the firestore.collection and pass\n  // in the name of our collection. This gets the\n  // 'collections' collection from firebase and stores\n  // it in the collectionRef const\n  const collectionRef = firestore.collection('collections'); // Instead of using the promise get().then() method that\n  // we used in our thunk code, we instead create a snapshot\n  // const that will be equal to the yielded value of running\n  // collectionReg.get(). When this value comes back, it does\n  // so in a promise form that gets resolved with the value\n  // of our collection reference, and stores it in our snapshot\n\n  const snapshot = yield collectionRef.get(); // call is the effect inside the generator function that invokes\n  // the method. It takes a function or method as its first argument\n  // and the parameters as the remaining arguments\n\n  const collectionsMap = yield call; // Now we want to get the data from it, so we need to\n  // use the get() method. This ensures that when\n  // the component runs for the first time or re-renders,\n  // we get the data that is running. We then use the then()\n  // method, which asynchronously gets the snapshot as the\n  // prop and then pass it into the\n  // convertCollectionSnapshotToMap function and store\n  // in a collectionsMap const.\n  // We then want to call our updateCollections action\n  // and pass the collectionsMap into it\n  // After creating our WithSpinner HOC, we also want\n  // to set the loading state to false once all the\n  // data is loaded\n  // collectionRef.get().then(snapshot => {\n  //     const collectionsMap = convertCollectionsSnapshotToMap(snapshot);\n  // We dispatch our fetchCollectionsSuccess function\n  // and pass in the collectionsMap, so that it\n  // is set as the payload\n  // dispatch(fetchCollectionsSuccess(collectionsMap));\n  // We then have a catch handler to get our error message,\n  // and we use the dispatch to dispatch the error.message\n  // into the fetchCollectionsFailure action\n  // }).catch(error => dispatch(fetchCollectionsFailure(error.message)));\n}\n; // We build our fetchCollectionsStart generator function\n// which is declared using the function* syntax\n// The generator function uses the takeEvery method which\n// listens to every action of a specific type (first argument),\n// and also a second generator function (second argument) - this\n// is how we step through the yield code\n\nexport function* fetchCollectionsStart() {\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}\n;","map":{"version":3,"sources":["/workspace/crwn-clothing/src/redux/shop/shop.sagas.js"],"names":["takeEvery","call","put","firestore","convertCollectionsSnapshotToMap","fetchCollectionsSuccess","fetchCollectionsFailure","ShopActionTypes","fetchCollectionsAsync","collectionRef","collection","snapshot","get","collectionsMap","fetchCollectionsStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,SAAT,EAAoBC,IAApB,EAA0BC,GAA1B,QAAqC,oBAArC,C,CAEA;;AACA,SACIC,SADJ,EAEIC,+BAFJ,QAGO,+BAHP,C,CAKA;;AACA,SACIC,uBADJ,EAEIC,uBAFJ,QAGO,gBAHP;AAKA,OAAOC,eAAP,MAA4B,cAA5B,C,CAEA;AACA;AACA;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACrC;AACA;AACA;AACA;AACA,QAAMC,aAAa,GAAGN,SAAS,CAACO,UAAV,CAAqB,aAArB,CAAtB,CALqC,CAMrC;AACA;AACA;AACA;AACA;AACA;;AACA,QAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAZqC,CAarC;AACA;AACA;;AACA,QAAMC,cAAc,GAAG,MAAMZ,IAA7B,CAhBqC,CAiBrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACJ;AACH;AAAA,C,CAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,UAAUa,qBAAV,GAAkC;AACrC,QAAMd,SAAS,CACXO,eAAe,CAACQ,uBADL,EAEXP,qBAFW,CAAf;AAIH;AAAA","sourcesContent":["// Import takeEvery to listen to every action of specific type\n// Import call to \n// Import put to \nimport { takeEvery, call, put } from 'redux-saga/effects';\n\n// Import relevant utilities from firebase utils\nimport {\n    firestore,\n    convertCollectionsSnapshotToMap\n} from '../../firebase/firebase.utils';\n\n// Import action creators from shop actions\nimport {\n    fetchCollectionsSuccess,\n    fetchCollectionsFailure\n} from './shop.actions';\n\nimport ShopActionTypes from './shop.types';\n\n// This generator function will be passed into the\n// fetchCollectionsStart generator function\n// This handled our code for the async request to\n// fetch the shop data\nexport function* fetchCollectionsAsync() {\n    // We want to call the firestore.collection and pass\n    // in the name of our collection. This gets the\n    // 'collections' collection from firebase and stores\n    // it in the collectionRef const\n    const collectionRef = firestore.collection('collections');\n    // Instead of using the promise get().then() method that\n    // we used in our thunk code, we instead create a snapshot\n    // const that will be equal to the yielded value of running\n    // collectionReg.get(). When this value comes back, it does\n    // so in a promise form that gets resolved with the value\n    // of our collection reference, and stores it in our snapshot\n    const snapshot = yield collectionRef.get();\n    // call is the effect inside the generator function that invokes\n    // the method. It takes a function or method as its first argument\n    // and the parameters as the remaining arguments\n    const collectionsMap = yield call \n    // Now we want to get the data from it, so we need to\n    // use the get() method. This ensures that when\n    // the component runs for the first time or re-renders,\n    // we get the data that is running. We then use the then()\n    // method, which asynchronously gets the snapshot as the\n    // prop and then pass it into the\n    // convertCollectionSnapshotToMap function and store\n    // in a collectionsMap const.\n    // We then want to call our updateCollections action\n    // and pass the collectionsMap into it\n    // After creating our WithSpinner HOC, we also want\n    // to set the loading state to false once all the\n    // data is loaded\n    // collectionRef.get().then(snapshot => {\n    //     const collectionsMap = convertCollectionsSnapshotToMap(snapshot);\n        // We dispatch our fetchCollectionsSuccess function\n        // and pass in the collectionsMap, so that it\n        // is set as the payload\n        // dispatch(fetchCollectionsSuccess(collectionsMap));\n        // We then have a catch handler to get our error message,\n        // and we use the dispatch to dispatch the error.message\n        // into the fetchCollectionsFailure action\n    // }).catch(error => dispatch(fetchCollectionsFailure(error.message)));\n};\n\n// We build our fetchCollectionsStart generator function\n// which is declared using the function* syntax\n// The generator function uses the takeEvery method which\n// listens to every action of a specific type (first argument),\n// and also a second generator function (second argument) - this\n// is how we step through the yield code\nexport function* fetchCollectionsStart() {\n    yield takeEvery(\n        ShopActionTypes.FETCH_COLLECTIONS_START,\n        fetchCollectionsAsync\n    );\n};\n"]},"metadata":{},"sourceType":"module"}