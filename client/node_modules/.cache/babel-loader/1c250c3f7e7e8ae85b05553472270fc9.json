{"ast":null,"code":"// Import takeLatest to listen to every action of specific type\n// Import call to enable creating the collectionsMap\n// Import put to enable us to dispatch any actions\nimport { takeLatest, call, put, all } from 'redux-saga/effects'; // Import relevant utilities from firebase utils\n\nimport { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils'; // Import action creators from shop actions\n\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from './shop.actions';\nimport ShopActionTypes from './shop.types'; // This generator function will be passed into the\n// fetchCollectionsStart generator function\n// This handled our code for the async request to\n// fetch the shop data\n\nexport function* fetchCollectionsAsync() {\n  try {\n    // We want to call the firestore.collection and pass\n    // in the name of our collection. This gets the\n    // 'collections' collection from firebase and stores\n    // it in the collectionRef const\n    const collectionRef = firestore.collection('collections'); // Instead of using the promise get().then() method that\n    // we used in our thunk code, we instead create a snapshot\n    // const that will be equal to the yielded value of running\n    // collectionReg.get(). When this value comes back, it does\n    // so in a promise form that gets resolved with the value\n    // of our collection reference, and stores it in our snapshot\n\n    const snapshot = yield collectionRef.get(); // call is the effect inside the generator function that invokes\n    // the method. It takes a function or method as its first argument\n    // and the parameters as the remaining arguments\n    // In this instance it takes the convertCollectionsSnapshotToMap\n    // function and passes in the snapshot parameter to create a\n    // collectionsMap\n\n    const collectionsMap = yield call(convertCollectionsSnapshotToMap, snapshot); // put is the saga effect for dispatching actions\n    // The only difference to dispatch() is that we have to\n    // yield it. So we need to pass in our fetchCollectionsSuccess\n    // action and pass in the collectionsMap, which gets dispatched\n\n    yield put(fetchCollectionsSuccess(collectionsMap));\n  } catch (error) {\n    // If there is an error, we use put to dispatch our\n    // fetchCollectionsFailure action with the error message\n    yield put(fetchCollectionsFailure(error.message));\n  }\n}\n; // We build our fetchCollectionsStart generator function\n// which is declared using the function* syntax\n// The generator function uses the takeLatest method which\n// listens to every action of a specific type (first argument),\n// and also a second generator function (second argument) - this\n// is how we step through the yield code. It only invokes the\n// latest action, so if the fetchCollectionsAsync Saga is run\n// multiple times, it will cancel all other previous ones\n\nexport function* fetchCollectionsStart() {\n  yield takeLatest(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}\n; // This is out root saga that all other sagas\n// are passed into\n\nexport function* shopSagas() {\n  yield all([call(fetchCollectionsStart)]);\n}\n;","map":{"version":3,"sources":["/workspace/crwn-clothing/client/src/redux/shop/shop.sagas.js"],"names":["takeLatest","call","put","all","firestore","convertCollectionsSnapshotToMap","fetchCollectionsSuccess","fetchCollectionsFailure","ShopActionTypes","fetchCollectionsAsync","collectionRef","collection","snapshot","get","collectionsMap","error","message","fetchCollectionsStart","FETCH_COLLECTIONS_START","shopSagas"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,UAAT,EAAqBC,IAArB,EAA2BC,GAA3B,EAAgCC,GAAhC,QAA2C,oBAA3C,C,CAEA;;AACA,SACIC,SADJ,EAEIC,+BAFJ,QAGO,+BAHP,C,CAKA;;AACA,SACIC,uBADJ,EAEIC,uBAFJ,QAGO,gBAHP;AAKA,OAAOC,eAAP,MAA4B,cAA5B,C,CAEA;AACA;AACA;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACrC,MAAI;AACA;AACA;AACA;AACA;AACA,UAAMC,aAAa,GAAGN,SAAS,CAACO,UAAV,CAAqB,aAArB,CAAtB,CALA,CAMA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMC,QAAQ,GAAG,MAAMF,aAAa,CAACG,GAAd,EAAvB,CAZA,CAaA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMC,cAAc,GAAG,MAAMb,IAAI,CAACI,+BAAD,EAAkCO,QAAlC,CAAjC,CAnBA,CAoBA;AACA;AACA;AACA;;AACA,UAAMV,GAAG,CAACI,uBAAuB,CAACQ,cAAD,CAAxB,CAAT;AACH,GAzBD,CAyBE,OAAOC,KAAP,EAAc;AACZ;AACA;AACA,UAAMb,GAAG,CAACK,uBAAuB,CAACQ,KAAK,CAACC,OAAP,CAAxB,CAAT;AACH;AACJ;AAAA,C,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACrC,QAAMjB,UAAU,CACZQ,eAAe,CAACU,uBADJ,EAEZT,qBAFY,CAAhB;AAIH;AAAA,C,CAED;AACA;;AACA,OAAO,UAAUU,SAAV,GAAsB;AACzB,QAAMhB,GAAG,CAAC,CACNF,IAAI,CAACgB,qBAAD,CADE,CAAD,CAAT;AAGH;AAAA","sourcesContent":["// Import takeLatest to listen to every action of specific type\n// Import call to enable creating the collectionsMap\n// Import put to enable us to dispatch any actions\nimport { takeLatest, call, put, all } from 'redux-saga/effects';\n\n// Import relevant utilities from firebase utils\nimport {\n    firestore,\n    convertCollectionsSnapshotToMap\n} from '../../firebase/firebase.utils';\n\n// Import action creators from shop actions\nimport {\n    fetchCollectionsSuccess,\n    fetchCollectionsFailure\n} from './shop.actions';\n\nimport ShopActionTypes from './shop.types';\n\n// This generator function will be passed into the\n// fetchCollectionsStart generator function\n// This handled our code for the async request to\n// fetch the shop data\nexport function* fetchCollectionsAsync() {\n    try {\n        // We want to call the firestore.collection and pass\n        // in the name of our collection. This gets the\n        // 'collections' collection from firebase and stores\n        // it in the collectionRef const\n        const collectionRef = firestore.collection('collections');\n        // Instead of using the promise get().then() method that\n        // we used in our thunk code, we instead create a snapshot\n        // const that will be equal to the yielded value of running\n        // collectionReg.get(). When this value comes back, it does\n        // so in a promise form that gets resolved with the value\n        // of our collection reference, and stores it in our snapshot\n        const snapshot = yield collectionRef.get();\n        // call is the effect inside the generator function that invokes\n        // the method. It takes a function or method as its first argument\n        // and the parameters as the remaining arguments\n        // In this instance it takes the convertCollectionsSnapshotToMap\n        // function and passes in the snapshot parameter to create a\n        // collectionsMap\n        const collectionsMap = yield call(convertCollectionsSnapshotToMap, snapshot);\n        // put is the saga effect for dispatching actions\n        // The only difference to dispatch() is that we have to\n        // yield it. So we need to pass in our fetchCollectionsSuccess\n        // action and pass in the collectionsMap, which gets dispatched\n        yield put(fetchCollectionsSuccess(collectionsMap));\n    } catch (error) {\n        // If there is an error, we use put to dispatch our\n        // fetchCollectionsFailure action with the error message\n        yield put(fetchCollectionsFailure(error.message));\n    }\n};\n\n// We build our fetchCollectionsStart generator function\n// which is declared using the function* syntax\n// The generator function uses the takeLatest method which\n// listens to every action of a specific type (first argument),\n// and also a second generator function (second argument) - this\n// is how we step through the yield code. It only invokes the\n// latest action, so if the fetchCollectionsAsync Saga is run\n// multiple times, it will cancel all other previous ones\nexport function* fetchCollectionsStart() {\n    yield takeLatest(\n        ShopActionTypes.FETCH_COLLECTIONS_START,\n        fetchCollectionsAsync\n    );\n};\n\n// This is out root saga that all other sagas\n// are passed into\nexport function* shopSagas() {\n    yield all([\n        call(fetchCollectionsStart)\n    ]);\n};\n"]},"metadata":{},"sourceType":"module"}