{"ast":null,"code":"// Import takeEvery to listen to every action of specific type\nimport { takeEvery } from 'redux-saga/effects'; // Import relevant utilities from firebase utils\n\nimport { firestore, convertCollectionsSnapshotToMap } from '../../firebase/firebase.utils'; // Import action creators from shop actions\n\nimport { fetchCollectionsSuccess, fetchCollectionsFailure } from './shop.actions';\nimport ShopActionTypes from './shop.types'; // This generator function will be passed into the\n// fetchCollectionsStart generator function\n// This handled our code for the async request to\n// fetch the shop data\n\nexport function* fetchCollectionsAsync() {\n  // We want to call the firestore.collection and pass\n  // in the name of our collection. This gets the\n  // 'collections' collection from firebase and stores\n  // it in the collectionRef const\n  const collectionRef = firestore.collection('collections'); // Now we want to get the data from it, so we need to\n  // use the get() method. This ensures that when\n  // the component runs for the first time or re-renders,\n  // we get the data that is running. We then use the then()\n  // method, which asynchronously gets the snapshot as the\n  // prop and then pass it into the\n  // convertCollectionSnapshotToMap function and store\n  // in a collectionsMap const.\n  // We then want to call our updateCollections action\n  // and pass the collectionsMap into it\n  // After creating our WithSpinner HOC, we also want\n  // to set the loading state to false once all the\n  // data is loaded\n\n  collectionRef.get().then(snapshot => {\n    const collectionsMap = convertCollectionsSnapshotToMap(snapshot); // We dispatch our fetchCollectionsSuccess function\n    // and pass in the collectionsMap, so that it\n    // is set as the payload\n\n    dispatch(fetchCollectionsSuccess(collectionsMap)); // We then have a catch handler to get our error message,\n    // and we use the dispatch to dispatch the error.message\n    // into the fetchCollectionsFailure action\n  }).catch(error => dispatch(fetchCollectionsFailure(error.message)));\n}\n; // We build our fetchCollectionsStart generator function\n// which is declared using the function* syntax\n// The generator function uses the takeEvery method which\n// listens to every action of a specific type (first argument),\n// and also a second generator function (second argument) - this\n// is how we step through the yield code\n\nexport function* fetchCollectionsStart() {\n  yield takeEvery(ShopActionTypes.FETCH_COLLECTIONS_START, fetchCollectionsAsync);\n}\n;","map":{"version":3,"sources":["/workspace/crwn-clothing/src/redux/shop/shop.sagas.js"],"names":["takeEvery","firestore","convertCollectionsSnapshotToMap","fetchCollectionsSuccess","fetchCollectionsFailure","ShopActionTypes","fetchCollectionsAsync","collectionRef","collection","get","then","snapshot","collectionsMap","dispatch","catch","error","message","fetchCollectionsStart","FETCH_COLLECTIONS_START"],"mappings":"AAAA;AACA,SAASA,SAAT,QAA0B,oBAA1B,C,CAEA;;AACA,SACIC,SADJ,EAEIC,+BAFJ,QAGO,+BAHP,C,CAKA;;AACA,SACIC,uBADJ,EAEIC,uBAFJ,QAGO,gBAHP;AAKA,OAAOC,eAAP,MAA4B,cAA5B,C,CAEA;AACA;AACA;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACrC;AACA;AACA;AACA;AACA,QAAMC,aAAa,GAAGN,SAAS,CAACO,UAAV,CAAqB,aAArB,CAAtB,CALqC,CAMrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAD,EAAAA,aAAa,CAACE,GAAd,GAAoBC,IAApB,CAAyBC,QAAQ,IAAI;AACjC,UAAMC,cAAc,GAAGV,+BAA+B,CAACS,QAAD,CAAtD,CADiC,CAEjC;AACA;AACA;;AACAE,IAAAA,QAAQ,CAACV,uBAAuB,CAACS,cAAD,CAAxB,CAAR,CALiC,CAMjC;AACA;AACA;AACH,GATD,EASGE,KATH,CASSC,KAAK,IAAIF,QAAQ,CAACT,uBAAuB,CAACW,KAAK,CAACC,OAAP,CAAxB,CAT1B;AAUH;AAAA,C,CAED;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,UAAUC,qBAAV,GAAkC;AACrC,QAAMjB,SAAS,CACXK,eAAe,CAACa,uBADL,EAEXZ,qBAFW,CAAf;AAIH;AAAA","sourcesContent":["// Import takeEvery to listen to every action of specific type\nimport { takeEvery } from 'redux-saga/effects';\n\n// Import relevant utilities from firebase utils\nimport {\n    firestore,\n    convertCollectionsSnapshotToMap\n} from '../../firebase/firebase.utils';\n\n// Import action creators from shop actions\nimport {\n    fetchCollectionsSuccess,\n    fetchCollectionsFailure\n} from './shop.actions'\n\nimport ShopActionTypes from './shop.types';\n\n// This generator function will be passed into the\n// fetchCollectionsStart generator function\n// This handled our code for the async request to\n// fetch the shop data\nexport function* fetchCollectionsAsync() {\n    // We want to call the firestore.collection and pass\n    // in the name of our collection. This gets the\n    // 'collections' collection from firebase and stores\n    // it in the collectionRef const\n    const collectionRef = firestore.collection('collections');\n    // Now we want to get the data from it, so we need to\n    // use the get() method. This ensures that when\n    // the component runs for the first time or re-renders,\n    // we get the data that is running. We then use the then()\n    // method, which asynchronously gets the snapshot as the\n    // prop and then pass it into the\n    // convertCollectionSnapshotToMap function and store\n    // in a collectionsMap const.\n    // We then want to call our updateCollections action\n    // and pass the collectionsMap into it\n    // After creating our WithSpinner HOC, we also want\n    // to set the loading state to false once all the\n    // data is loaded\n    collectionRef.get().then(snapshot => {\n        const collectionsMap = convertCollectionsSnapshotToMap(snapshot);\n        // We dispatch our fetchCollectionsSuccess function\n        // and pass in the collectionsMap, so that it\n        // is set as the payload\n        dispatch(fetchCollectionsSuccess(collectionsMap));\n        // We then have a catch handler to get our error message,\n        // and we use the dispatch to dispatch the error.message\n        // into the fetchCollectionsFailure action\n    }).catch(error => dispatch(fetchCollectionsFailure(error.message)));\n};\n\n// We build our fetchCollectionsStart generator function\n// which is declared using the function* syntax\n// The generator function uses the takeEvery method which\n// listens to every action of a specific type (first argument),\n// and also a second generator function (second argument) - this\n// is how we step through the yield code\nexport function* fetchCollectionsStart() {\n    yield takeEvery(\n        ShopActionTypes.FETCH_COLLECTIONS_START,\n        fetchCollectionsAsync\n    );\n};\n"]},"metadata":{},"sourceType":"module"}